let data = [];
let commits = [];
let selectedCommits = [];
let xScale, yScale, rScale;
let fileTypeColors;

// Variables for time slider
let commitProgress = 100;
let timeScale;
let commitMaxTime;
let filteredCommits = [];

// Variables for scrollytelling
let ITEM_HEIGHT = 120; // Increased height for better spacing
let VISIBLE_COUNT = 15; // Number of visible items

async function loadData() {
  try {
    // Load the CSV generated by our custom script
    data = await d3.csv('loc.csv', (row) => {
      // Extract the file name from the commit data
      const fileName = row.file || inferFileNameFromData(row);
      
      return {
        ...row,
        line: Number(row.line),
        depth: Number(row.depth),
        length: Number(row.length),
        files_changed: Number(row.files_changed || 1),
        date: new Date(row.date + 'T' + row.time),
        datetime: new Date(row.datetime),
        file: fileName
      };
    });
    
    console.log("Loaded", data.length, "entries from loc.csv");
    processCommits();
    console.log("Processed", commits.length, "unique commits");
    
    // Initialize time scale
    setupTimeScale();
    
    // Initialize visualizations
    displayStats(commits);
    setupTimeSlider();
    setupScrollytelling();
    updateScatterplot(commits);
    displayCommitFiles(commits);
    setupFilesScrollytelling();
  } catch (error) {
    console.error("Error loading data:", error);
  }
}

// Helper function to try to infer file names if they're not explicitly provided
function inferFileNameFromData(row) {
  // In a real implementation, you might extract this from commit message or other data
  // For now, we'll create some example file names based on the commit hash
  const fileExtensions = ['js', 'html', 'css', 'json', 'md'];
  const prefix = row.commit.slice(0, 2); // Use first 2 chars of commit hash
  const ext = fileExtensions[Math.floor(Math.random() * fileExtensions.length)];
  return `src/file-${prefix}.${ext}`;
}

document.addEventListener('DOMContentLoaded', loadData);

function processCommits() {
  // Group data by commit hash to collect all lines per commit
  commits = [];
  const commitGroups = d3.group(data, d => d.commit);
  
  commitGroups.forEach((lines, commit) => {
    if (lines.length > 0) {
      const sample = lines[0]; // Use the first line for common commit data
      
      // Get all unique file names in this commit
      const files = Array.from(new Set(lines.map(line => line.file))).filter(Boolean);
      
      // Get lines changed count
      const linesChanged = lines.reduce((sum, line) => sum + Number(line.length || 1), 0);
      
      // Create a commit object with accurate timestamp
      commits.push({
        id: commit,
        url: `https://github.com/ShaheerAlamKhan/portfolio/commit/${commit}`,
        author: sample.author,
        datetime: new Date(sample.datetime),
        hourFrac: new Date(sample.datetime).getHours() + new Date(sample.datetime).getMinutes() / 60,
        totalLines: linesChanged, // Use actual lines changed
        files_changed: sample.files_changed || files.length,
        files: files,
        lines: lines
      });
    }
  });
  
  // Sort commits by date (oldest first for chronological display)
  commits.sort((a, b) => a.datetime - b.datetime);
  
  console.log(`Processed ${commits.length} commits with the following files:`, 
    Array.from(new Set(commits.flatMap(commit => commit.files))));
}

function setupTimeScale() {
  // Create a time scale for the slider
  const timeExtent = d3.extent(commits, d => d.datetime);
  timeScale = d3.scaleTime()
    .domain(timeExtent)
    .range([0, 100]);
    
  // Set initial commit max time to latest commit
  commitMaxTime = timeExtent[1];
}

function setupTimeSlider() {
  const timeSlider = document.getElementById('time-slider');
  const selectedTime = document.getElementById('selectedTime');
  
  // Set initial time display
  selectedTime.textContent = commitMaxTime.toLocaleString('en', {
    dateStyle: 'medium',
    timeStyle: 'short'
  });
  
  // Update time and visualizations when slider changes
  timeSlider.addEventListener('input', function() {
    commitProgress = Number(this.value);
    updateTimeDisplay();
  });
}

function updateTimeDisplay() {
  const selectedTime = document.getElementById('selectedTime');
  
  // Update max time based on slider value
  commitMaxTime = timeScale.invert(commitProgress);
  
  // Update time display
  selectedTime.textContent = commitMaxTime.toLocaleString('en', {
    dateStyle: 'medium',
    timeStyle: 'short'
  });
  
  // Filter commits by time
  filteredCommits = commits.filter(commit => commit.datetime <= commitMaxTime);
  
  // Update visualizations
  displayStats(filteredCommits);
  updateScatterplot(filteredCommits);
  displayCommitFiles(filteredCommits);
  
  // Update scrollytelling to match time
  updateScrollPosition();
}

function updateScrollPosition() {
  // Find the index of the last visible commit based on time filter
  if (filteredCommits.length === 0) return;
  
  const lastVisibleCommit = filteredCommits[filteredCommits.length - 1];
  const lastVisibleIndex = commits.findIndex(c => c.id === lastVisibleCommit.id);
  
  if (lastVisibleIndex >= 0) {
    const scrollContainer = document.getElementById('scroll-container');
    const targetScrollPosition = Math.max(0, (lastVisibleIndex - VISIBLE_COUNT/2)) * ITEM_HEIGHT;
    
    // Smooth scroll to the position
    scrollContainer.scrollTo({
      top: targetScrollPosition,
      behavior: 'smooth'
    });
  }
}

function displayStats(visibleCommits) {
  const statsContainer = d3.select('#stats');
  statsContainer.html(''); // Clear existing stats
  
  // Calculate statistics based on filtered commits
  const totalCommits = visibleCommits.length;
  const uniqueFiles = new Set();
  visibleCommits.forEach(commit => commit.files.forEach(file => uniqueFiles.add(file)));
  const totalFiles = uniqueFiles.size;
  const totalLOC = visibleCommits.reduce((sum, commit) => sum + commit.totalLines, 0);
  const maxDepth = d3.max(visibleCommits.flatMap(commit => commit.lines.map(line => line.depth))) || 0;
  const longestLine = d3.max(visibleCommits.flatMap(commit => commit.lines.map(line => line.length))) || 0;
  const maxLines = d3.max(visibleCommits, commit => commit.totalLines) || 0;
  
  // Create stat items with icons and animations
  createStatItem(statsContainer, 'COMMITS', totalCommits, 'commit-icon');
  createStatItem(statsContainer, 'FILES', totalFiles, 'file-icon');
  createStatItem(statsContainer, 'TOTAL LOC', totalLOC, 'code-icon');
  createStatItem(statsContainer, 'MAX DEPTH', maxDepth, 'depth-icon');
  createStatItem(statsContainer, 'LONGEST LINE', longestLine, 'length-icon');
  createStatItem(statsContainer, 'MAX LINES', maxLines, 'lines-icon');
}

function createStatItem(container, label, value, iconClass) {
  const statItem = container.append('div')
    .attr('class', 'stat-item');
    
  statItem.append('div')
    .attr('class', 'stat-icon ' + iconClass);
    
  statItem.append('div')
    .attr('class', 'stat-label')
    .text(label);
    
  statItem.append('div')
    .attr('class', 'stat-value')
    .text(value)
    .style('opacity', 0)
    .transition()
    .duration(800)
    .style('opacity', 1);
}

function isCommitSelected(commit) {
  return selectedCommits.includes(commit);
}

function updateScatterplot(filteredCommits) {
  // Clear existing SVG
  d3.select('#chart').selectAll('svg').remove();
  
  // Increased dimensions for better readability
  const width = 1200;
  const height = 500;

  const svg = d3.select('#chart')
    .append('svg')
    .attr('viewBox', `0 0 ${width} ${height}`)
    .style('overflow', 'visible');

  // Create scales
  xScale = d3.scaleTime()
    .domain(d3.extent(commits, d => d.datetime)) // Use all commits for consistent scaling
    .range([0, width])
    .nice();

  yScale = d3.scaleLinear()
    .domain([0, 24])
    .range([height, 0]);

  // Define margins
  const margin = { top: 20, right: 30, bottom: 40, left: 50 };
  const usableArea = {
    top: margin.top,
    right: width - margin.right,
    bottom: height - margin.bottom,
    left: margin.left,
    width: width - margin.left - margin.right,
    height: height - margin.top - margin.bottom
  };

  // Update scales to account for margins
  xScale.range([usableArea.left, usableArea.right]);
  yScale.range([usableArea.bottom, usableArea.top]);

  // Group for dots
  const dots = svg.append('g').attr('class', 'dots');

  // Sort commits so larger ones (by totalLines) are drawn first
  const sortedCommits = d3.sort(filteredCommits, (a, b) => b.totalLines - a.totalLines);

  // Create a radius scale based on totalLines - increase min radius for better visibility
  const [minLines, maxLines] = d3.extent(commits, d => d.totalLines); // Use all commits for consistent scaling
  rScale = d3.scaleSqrt()
    .domain([minLines, maxLines])
    .range([5, 35]);

  // Bind data and add circles
  dots.selectAll('circle')
    .data(sortedCommits)
    .join('circle')
    .attr('cx', d => xScale(d.datetime))
    .attr('cy', d => yScale(d.hourFrac))
    .attr('r', d => rScale(d.totalLines))
    .attr('fill', 'steelblue')
    .style('fill-opacity', 0.7)
    .style('--r', d => rScale(d.totalLines)) // For CSS transition
    .on('mouseenter', (event, d) => {
      d3.select(event.currentTarget).classed('selected', true);
      updateTooltipContent(d);
      updateTooltipVisibility(true);
      updateTooltipPosition(event);
    })
    .on('mouseleave', (event) => {
      d3.select(event.currentTarget).classed('selected', false);
      updateTooltipContent({});
      updateTooltipVisibility(false);
    })
    .on('mousemove', (event) => {
      updateTooltipPosition(event);
    });

  // Add X axis with increased font size
  const xAxis = d3.axisBottom(xScale)
    .ticks(10);
  svg.append('g')
    .attr('transform', `translate(0, ${usableArea.bottom})`)
    .call(xAxis)
    .selectAll('text')
    .style('font-size', '12px');

  // Add Y axis with formatted ticks (00:00, 01:00, etc.) and increased font size
  const yAxis = d3.axisLeft(yScale)
    .tickFormat(d => String(d % 24).padStart(2, '0') + ':00');
  svg.append('g')
    .attr('transform', `translate(${usableArea.left}, 0)`)
    .call(yAxis)
    .selectAll('text')
    .style('font-size', '12px');

  // Add axis labels
  svg.append('text')
    .attr('class', 'axis-label')
    .attr('text-anchor', 'middle')
    .attr('x', usableArea.left + usableArea.width / 2)
    .attr('y', height - 5)
    .text('Date');

  svg.append('text')
    .attr('class', 'axis-label')
    .attr('text-anchor', 'middle')
    .attr('transform', `rotate(-90)`)
    .attr('x', -height / 2)
    .attr('y', 15)
    .text('Time of Day');

  // Add horizontal gridlines
  const gridlines = svg.append('g')
    .attr('class', 'gridlines')
    .attr('transform', `translate(${usableArea.left}, 0)`);
  gridlines.call(
    d3.axisLeft(yScale)
      .tickFormat('')
      .tickSize(-usableArea.width)
  );
}

function updateTooltipContent(commit) {
  const link = document.getElementById('commit-link');
  const date = document.getElementById('commit-date');
  
  if (!commit || Object.keys(commit).length === 0) {
    link.href = '';
    link.textContent = '';
    date.textContent = '';
    return;
  }
  
  link.href = commit.url;
  link.textContent = commit.id;
  date.textContent = commit.datetime.toLocaleString('en', {
    dateStyle: 'full'
  });
}

function updateTooltipVisibility(isVisible) {
  const tooltip = document.getElementById('commit-tooltip');
  tooltip.hidden = !isVisible;
}

function updateTooltipPosition(event) {
  const tooltip = document.getElementById('commit-tooltip');
  tooltip.style.left = `${event.clientX + 10}px`;
  tooltip.style.top = `${event.clientY + 10}px`;
}

// Scrollytelling implementation
function setupScrollytelling() {
  // Show all commits - calculate total height
  const totalHeight = commits.length * ITEM_HEIGHT;
  
  const scrollContainer = d3.select('#scroll-container');
  const spacer = d3.select('#spacer');
  
  // Set spacer height to create scrollable area
  spacer.style('height', `${totalHeight}px`);
  
  // Listen for scroll events
  scrollContainer.on('scroll', () => {
    const scrollTop = scrollContainer.property('scrollTop');
    let startIndex = Math.floor(scrollTop / ITEM_HEIGHT);
    startIndex = Math.max(0, Math.min(startIndex, commits.length - VISIBLE_COUNT));
    
    renderItems(startIndex);
    
    // Synchronize time slider with scroll position
    syncTimeSliderWithScroll(startIndex);
  });
  
  // Initial render - show the first set of commits (oldest first)
  renderItems(0);
}

function syncTimeSliderWithScroll(startIndex) {
  const visibleCommits = commits.slice(startIndex, startIndex + VISIBLE_COUNT);
  if (visibleCommits.length === 0) return;
  
  // Use the datetime of the last visible commit to set the slider
  const lastVisibleCommit = visibleCommits[visibleCommits.length - 1];
  const sliderValue = timeScale(lastVisibleCommit.datetime);
  
  // Update slider without triggering the input event
  const timeSlider = document.getElementById('time-slider');
  if (Math.abs(timeSlider.value - sliderValue) > 1) { // Only update if significant change
    timeSlider.value = sliderValue;
    commitProgress = sliderValue;
    commitMaxTime = lastVisibleCommit.datetime;
    
    // Update time display
    document.getElementById('selectedTime').textContent = commitMaxTime.toLocaleString('en', {
      dateStyle: 'medium',
      timeStyle: 'short'
    });
    
    // Filter commits and update visualizations
    filteredCommits = commits.filter(commit => commit.datetime <= commitMaxTime);
    displayStats(filteredCommits);
    updateScatterplot(filteredCommits);
    // Don't call displayCommitFiles here as it's now called in renderItems
  }
}

function renderItems(startIndex) {
  // Clear previous items
  const itemsContainer = d3.select('#items-container');
  itemsContainer.selectAll('div').remove();
  
  // Get visible commits slice - oldest commits at the top
  const endIndex = Math.min(startIndex + VISIBLE_COUNT, commits.length);
  const visibleCommits = commits.slice(startIndex, endIndex);
  
  // Create narrative items
  visibleCommits.forEach((commit, idx) => {
    const item = itemsContainer.append('div')
      .attr('class', 'item')
      .style('position', 'absolute')
      .style('top', `${idx * ITEM_HEIGHT}px`)
      .style('width', '100%')
      .style('height', `${ITEM_HEIGHT - 10}px`);
    
    // Generate narrative content
    const formattedDate = commit.datetime.toLocaleString("en", {
      dateStyle: "full", 
      timeStyle: "short"
    });
    
    const isFirstCommit = commits.indexOf(commit) === 0;
    
    item.html(`
      <p>
        On ${formattedDate}, I made 
        <a href="${commit.url}" target="_blank">
          ${isFirstCommit ? 'my first commit, and it was glorious' : 'another glorious commit'}
        </a>. 
        I edited ${commit.totalLines} lines across ${commit.files_changed} files. 
        Then I looked over all I had made, and I saw that it was very good.
      </p>
    `);
  });
  
  // Update the file visualization to match the latest visible commit
  if (visibleCommits.length > 0) {
    // Use the most recent visible commit to filter files
    const latestVisibleCommit = visibleCommits[visibleCommits.length - 1];
    const timeOfLatestVisibleCommit = latestVisibleCommit.datetime;
    
    // Filter commits up to this point in time
    const commitsUpToLatestVisible = commits.filter(commit => 
      commit.datetime <= timeOfLatestVisibleCommit
    );
    
    // Update the file visualization
    displayCommitFiles(commitsUpToLatestVisible);
  }
}

function displayCommitFiles(filteredCommits) {
  // Get all lines from filtered commits
  const lines = filteredCommits.flatMap((d) => d.lines);
  fileTypeColors = d3.scaleOrdinal(d3.schemeTableau10);
  
  // Group lines by file - only include files from the filtered commits
  let files = d3.groups(lines, (d) => d.file)
    .filter(([name]) => name && name !== 'undefined')
    .map(([name, lines]) => {
      return { name, lines };
    });
  
  // Sort files by number of lines in descending order
  files = d3.sort(files, (d) => -d.lines.length);
  
  // Clear and update the file display
  d3.select('.files').selectAll('div').remove();
  
  // Create file visualization with transition effects
  let filesContainer = d3.select('.files')
    .selectAll('div')
    .data(files, d => d.name) // Use file name as key for better transitions
    .enter()
    .append('div')
    .attr('class', 'file-entry')
    .style('opacity', 0)
    .transition()
    .duration(500)
    .style('opacity', 1);
  
  // Add file names and line counts
  filesContainer.selection().append('dt')
    .html(d => `<code>${d.name}</code><small>${d.lines.length} lines</small>`);
  
  // Add unit visualization (dots) for lines
  filesContainer.selection().append('dd')
    .each(function(d) {
      const container = d3.select(this);
      
      d.lines.forEach((line, i) => {
        container.append('div')
          .attr('class', 'line')
          .style('background', getFileColor(line.file))
          .style('animation-delay', `${i * 2}ms`); // Faster animation
      });
    });
  
  // Update the selection count
  document.getElementById('selection-count').textContent = 
    filteredCommits.length > 0 ? `Showing codebase after ${filteredCommits.length} commits` : 'No commits selected';
}

function getFileColor(filename) {
  if (!filename) return fileTypeColors('unknown');
  
  // Determine file type by extension
  const ext = filename.split('.').pop();
  return fileTypeColors(ext);
}

function renderFileNarrative(startIndex) {
  // Clear previous items
  const filesItemsContainer = d3.select('#files-items-container');
  filesItemsContainer.selectAll('div').remove();
  
  // Calculate visible range
  const endIndex = Math.min(startIndex + VISIBLE_COUNT, commits.length);
  const visibleCommits = commits.slice(startIndex, endIndex);
  
  // Create narrative items for each visible commit
  visibleCommits.forEach((commit, idx) => {
    const item = filesItemsContainer.append('div')
      .attr('class', 'item')
      .style('position', 'absolute')
      .style('top', `${idx * ITEM_HEIGHT}px`)
      .style('width', '100%')
      .style('height', `${ITEM_HEIGHT - 10}px`);
    
    const formattedDate = commit.datetime.toLocaleString("en", {
      dateStyle: "full", 
      timeStyle: "short"
    });
    
    // Generate narrative specific to this commit's file changes
    const filesList = commit.files.length > 0
      ? commit.files.map(file => `<li><code>${file}</code></li>`).join('')
      : '<li><em>No files modified</em></li>';
    
    item.html(`
      <h3>Commit on ${formattedDate}</h3>
      <p>This commit modified ${commit.files.length} file${commit.files.length !== 1 ? 's' : ''} with a total of ${commit.totalLines} line changes:</p>
      <ul class="files-modified">
        ${filesList}
      </ul>
    `);
  });
}

// Files scrollytelling implementation
function setupFilesScrollytelling() {
  // Variables for files scrollytelling
  const fileScrollContainer = d3.select('#files-scroll-container');
  const filesSpacer = d3.select('#files-spacer');
  const filesItemsContainer = d3.select('#files-items-container');
  
  // Set height based on number of commits
  const scrollHeight = commits.length * ITEM_HEIGHT;
  
  // Set spacer height to create scrollable area
  filesSpacer.style('height', `${scrollHeight}px`);
  
  // Listen for scroll events
  fileScrollContainer.on('scroll', () => {
    const scrollTop = fileScrollContainer.property('scrollTop');
    
    // Calculate which range of commits to display in narrative
    let startIndex = Math.floor(scrollTop / ITEM_HEIGHT);
    startIndex = Math.max(0, Math.min(startIndex, commits.length - VISIBLE_COUNT));
    
    // Calculate commit index for file visualization (based on last visible in window)
    const visibleCommits = commits.slice(startIndex, startIndex + VISIBLE_COUNT);
    const latestVisibleCommit = visibleCommits[visibleCommits.length - 1];
    
    // Find index of this commit
    const commitIndex = commits.findIndex(c => c.id === latestVisibleCommit.id);
    
    // Show the state of the codebase up to this commit
    const commitsUpToPoint = commits.slice(0, commitIndex + 1);
    displayCommitFiles(commitsUpToPoint);
    
    // Update the narrative in the files scroll container
    renderFileNarrative(startIndex);
  });
  
  // Initial render showing the first commit only
  displayCommitFiles(commits.slice(0, 1));
  renderFileNarrative(0);
}


function renderFileItems(startIndex, allFiles) {
  // Clear previous items
  const filesItemsContainer = d3.select('#files-items-container');
  filesItemsContainer.selectAll('div').remove();
  
  // Handle empty file list
  if (allFiles.length === 0) {
    filesItemsContainer.append('div')
      .attr('class', 'item')
      .style('position', 'absolute')
      .style('top', '0px')
      .html('<p>No files available in the current selection.</p>');
    return;
  }
  
  // Sort files by size (we need to get line count for each file)
  const fileLineCount = new Map();
  commits.forEach(commit => {
    commit.lines.forEach(line => {
      if (!line.file) return;
      
      if (!fileLineCount.has(line.file)) {
        fileLineCount.set(line.file, 0);
      }
      fileLineCount.set(line.file, fileLineCount.get(line.file) + 1);
    });
  });
  
  // Sort files by line count
  const sortedFiles = [...allFiles].sort((a, b) => {
    return (fileLineCount.get(b) || 0) - (fileLineCount.get(a) || 0);
  });
  
  // Get visible files slice - show more files
  const endIndex = Math.min(startIndex + VISIBLE_COUNT, sortedFiles.length);
  const visibleFiles = sortedFiles.slice(startIndex, endIndex);
  
  // Create narrative items
  visibleFiles.forEach((file, idx) => {
    const item = filesItemsContainer.append('div')
      .attr('class', 'item')
      .style('position', 'absolute')
      .style('top', `${idx * ITEM_HEIGHT}px`)
      .style('width', '100%')
      .style('height', `${ITEM_HEIGHT - 10}px`);
    
    // Get commits that modified this file
    const fileCommits = commits.filter(commit => commit.files.includes(file));
    const lineCount = fileLineCount.get(file) || 0;
    const fileExt = file.split('.').pop();
    
    item.html(`
      <p>
        The file <code>${file}</code> contains ${lineCount} lines of code. 
        It has been modified in ${fileCommits.length} commit${fileCommits.length !== 1 ? 's' : ''}.
        This is a ${fileExt} file, which contributes to the ${fileExt === 'js' ? 'functionality' : 
                             fileExt === 'css' ? 'styling' : 
                             fileExt === 'html' ? 'structure' : 'content'} 
        of the website.
      </p>
    `);
  });
}